## 散列表

### 时间复杂度

- 查询 O(1)
- 修改 O(1)
- 删除 O(1)
- 遍历：无法有序遍历 (需要实现 Ordered Hash Map)

### 实现

- 散列函数：高低位异或后取模
- 散列冲突解决：链表法
- 装载因子：0.75，只扩容，不缩容

## LRU 缓存机制
利用双向链表和散列表实现 LRU（Least Recently Used) 缓存机制

插入 Key, Value 时：

- 在散列表中查找 Key，如果存在，说明 Key 已经在缓存中：
  1. 从链表中将 Key 移除，并将 Key 插入链表头
- 如果不存在，新增 Key：
  - 如果缓存空间已满：
    - 删除链表尾的元素
  - 将 Key 插入到链表头

> 为了实现简单，用链表元素数量的个数来判断缓存空间是否已满

